



/**
 * 随机生成一个长度为 10 的整数类型的数组，
 * 例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，
 * 将其排列成一个新数组，要求新数组形式如下，
 * 例如 [[2, 3, 4, 5], [10, 11], [20]]。
 */


/**
 * 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置
 */




/**
 * 算法题「旋转数组」
 * 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
 * 输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3
 * 输出: [5, 6, 7, 1, 2, 3, 4]
 * 解释:
 * 向右旋转 1 步: [7, 1, 2, 3, 4, 5, 6]
 * 向右旋转 2 步: [6, 7, 1, 2, 3, 4, 5]
 * 向右旋转 3 步: [5, 6, 7, 1, 2, 3, 4]
 */

/**
 * 打印出 1 - 10000 之间的所有对称数
 */

/**
 * 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
 * 示例:
 * 输入: [0,1,0,3,12]
 * 输出: [1,3,12,0,0]
 * 说明: 必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。
 */

/**
 * 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。
 * 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。
 * 示例：
 * 给定 nums = [2, 7, 11, 15], target = 9
 * 因为 nums[0] + nums[1] = 2 + 7 = 9
 * 所以返回 [0, 1]
 */

/**
 * 已知数据格式，实现一个函数 fn 找出链条中所有的父级 id
 * const value = '112'
 * const fn = (value) => {}
 * fn(value) // 输出 [1， 11， 11
 */

/**
 * 模拟实现一个深拷贝，并考虑对象相互引用以及 Symbol 拷贝的情况
 */

/**
 * 用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。
 * 如：输入整型 1234，返回字符串“4321”。
 * 要求必须使用递归函数调用，不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。
 */
