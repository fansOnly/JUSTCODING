// ==========================================================================================
// ============================== 浏览器渲染 =================================================
// ==========================================================================================

// ============================== 浏览器渲染流程 ==============================

// 1 html 和 css 各自经过解析，生成 dom树 和 cssom树
// 2 dom树 和 cssom树 合并成为渲染树
// 3 根据渲染树进行布局
// 4 调用 GPU 进行绘制，显示在屏幕上


// ============================== 首屏优化 ==============================

// 1 优化文件大小：html 和 css 的加载和解析都会阻塞渲染树的生成，优化文件大小，减少 css 层级
// 2 避免资源下载阻塞文档解析：当浏览器遇到 script 标签时，会阻塞解析文档，知道脚本执行完成。可以将 script 标签放在文档底部，或者通过 defer/async 等属性异步加载


// ============================== 浏览器回流（重排）-- 高消耗 ==============================

// 1 当浏览器的尺寸或者位置发生了变化，就会重新计算渲染树，成为回流
// 2 DOM 元素的几何属性(width/height/padding/margin/border)发生变化
// 3 DOM 元素的移动或者增加
// 4 读写 offset/scroll/client 等属性时
// 5 调用 window.getComputedStyle 时


// ============================== 浏览器重绘 ==============================

// DOM 样式发生了变化,但没有影响到 DOM 的集合属性时,会触发重绘


// ============================== GPU 加速 ==============================

// 优点 使用 transform/opacity/filters 等属性时, 会直接在 GPU 中完成处理, 不会引起回流重绘
// 缺点 GPU 渲染字体会导致模糊, 过多的 GPU 处理回导致内存问题


// ============================== 回流/重绘的优化 ==============================

// 1 使用 class 替代 style, 减少 style 的使用
// 2 scroll 和 resize 会导致回流, 使用时进行防抖和节流处理
// 3 使用 visibility 替代 display:none, 前者导致重绘, 后者导致回流
// 4 批量修改元素时, 先脱离文档流, 修改完后在放入文档
// 5 避免触发同步布局事件,在回去 offsetWidth 等属性时,将值缓存起来,避免多次查询,每次查询都会导致回流
// 6 对于复杂的动画效果,使用绝对定位让其脱离文档流,避免频繁的触发回流和重绘




// ==========================================================================================
// ============================== 浏览器缓存 =================================================
// ==========================================================================================

// ============================== 缓存位置及优先级 ==============================

// 1 service worker
// a 跟 web worker 类似，独立的线程
// b 可以设置缓存文件和文件的匹配 读取规则
// c 持续性缓存

// 2 memory cache 内存缓存
// a 非持续性缓存，随着进程的释放而释放

// 3 disk cache 硬盘缓存
// a 持续性和容量相比 memory chahe 更好
// b 可以在 HTTP header 设置缓存资源

// ps 1 浏览器会将比较大的js css 文件丢进磁盘, 其他的丢进内存
// ps 2 内存使用率比较高的时候, 文件优先进入磁盘

// 4 push cache 推送缓存
// a HTTP/2 

// 5 以上都未命中则发起网络请求


// ============================== 浏览器缓存策略 ==============================

// 1 强缓存 - 不需要向服务器询问

// a 设置 Expires：过期时间，绝对日期，修改本地时间会影响到缓存
// b 设置 Cache-Control：HTTP/1.1，可以设置 max-age/privite/no-cache 等字段

// 2 策略缓存 - 需要向服务器询问缓存过期时间

// a Last-Modified：最后修改时间
// 第一次请求 - Last-Modified - 再次请求 - If-Modified-Since - 相同 - 返回 304
// 第一次请求 - Last-Modified - 再次请求 - If-Modified-Since - 不相同 - 返回新资源，更新 Last-Modified

// b ETag：HTTP/1.1，文件唯一标识，跟随内容更新
// 第一次请求 - ETag - 再次请求 - If-None-Match - 相同 - 返回 304
// 第一次请求 - ETag - 再次请求 - If-None-Match - 不相同 - 返回新资源，更新 ETag

// 3 ETag 相比 Last-Modified 更准确
// 4 如果未设置任何缓存策略，浏览器会读取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间




// =======================================================================================================
// =================================== 从输入URL到页面呈现发生了什么 =======================================
// =======================================================================================================

// 从输入URL到页面呈现发生了什么