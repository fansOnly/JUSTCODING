#### 从浏览器输入URL到页面的展现，究竟发生了什么不可告人的秘密

---

##### 1、浏览器解析URL获取协议，主机，端口

##### 2、浏览器组装一个HTTP（GET）请求

##### 3、浏览器获取IP地址

+ DNS解析过程：

  + 浏览器查找自身DNS缓存

  + 浏览器在向本机查询（windows系统中域名和IP的映射关系存在host文件）

  + 浏览器向本地域名服务器查询，使用递归查询：如果本地域名服务器不知道要查询的域名IP地址，那么本地域名服务器会以DNS客户的身份向根域名服务器查询（代替主机查询）

  + 本地域名服务器采用迭代查询：当根域名服务器接收到本地域名服务器的查询请求时，要么返回IP地址，要么告诉本地域名服务器下一步向那个域名服务器查询
    > PS：主机 a.xyz.com 向 m.abc.com 发送邮件
    > 1 主机 a.xyz.com 向本地服务器 dns.xyz.com 查询
    > 2 本地服务器采用迭代查询，先向根域名服务器查询
    > 3 根域名服务器告诉本地服务器，下一次应该向顶级域名服务器 dns.com 查询
    > 4 本地域名服务器向顶级域名服务器 dnf.com 查询
    > 5 顶级域名服务器告诉本地服务器，下一次应该向权限域名服务器 dns.abc.com 查询
    > 6 本地域名服务器向权限域名服务器 dns.abc.com 查询
    > 7 权限域名服务器告诉本地服务器所查询的主机的 IP 地址
    > 8 本地域名服务器把查询结果告诉给 a.xyz.com

##### 4、打开一个 socket 与目标IP地址，端口建立TCP链接

+ TCP的三次握手
  + 客户端向将标志位-请求连接SYN = 1，随机产生一个值为seq = J的数据包发送到服务端，进入SYN_SENT状态
  + 服务端接收后，将标志位SYN = 1，ACK = 1，确认号ack = J+1，随机产生一个值为seq = K 的数据包发送给客户端，进入SYN_RCVD状态
  + 客户端接收后，将标志位ACK = 1，确认号ack = K+1 发送给服务端，服务端检查ACK=1，ack = K+1确认连接成功，客户端和服务端同时进入ESTABLISGHED状态

+ TCP的四次挥手
  + 客户端将标志位-断开连接FIN = 1，随机产生一个值为seq = J的数据包发送给服务端，进入FIN_WAIT_1状态
  + 服务端接收后，将ACK = 1，确认号ack = J+1，发送给客户端，进入CLOSE_WAIT状态，客户端接收后进入FIN_WAIT_2状态
  + 服务端等待一段时间，将FIN = 1 ACK = 1，seq = K，确认号ack = J+1 发送给客户端，进入LAST_ACK状态
  + 客户端接收后进入TIME_WAIT状态，将ACK = 1，seq = J+1, 确认号ack = K+1 发送给服务端，服务端接收后进入CLOSED状态

##### 5、TCP链接后建立发送HTTP请求

+ HTTP 首部
  + 通用首部
    + Cache-Control：缓存控制
    + Connection：连接管理
    + Transfor-Encoding：报文主体的传输编码格式
    + Date：创建报文的时间
    + Upgrade：升级为其他协议
  + 请求首部
    + Host：请求资源所在的服务器地址，HTTP1.1规范唯一要求的字段
    + Accept：客户端或者代理能够处理的媒体类型
    + If-Match：比较实体标记 ETag
    + If-None-Match：比较实体标记 ETag
    + If-Modified-Since：比较资源更新时间 Last-Modified
    + If-Unmodified-Since：比较资源更新时间 Last-Modified
    + Range：实体的字节范围请求
    + User-Agent：客户端信息
  + 响应首部
    + Accept-Ranges：能接受的字节范围
    + Location：命令客户端重定向的地址
    + ETag：表示资源唯一的标识符
    + Server：服务器信息
  + 实体首部
    + Allow：允许的HTTP请求方法
    + Last-Modified：资源最后修改时间
    + Expires：实体主体过期时间
    + Content-Language：实体资源语言
    + Content-Encoding：实体编码格式
    + Content-length：实体大小
    + COntent-type：实体媒体类型

+ HTTP 缓存
  + 强缓存
    + HTTP 1.0：Expires
    + HTTP 1.1：Cache-Control，优先级高
        > max-age：缓存的最大有效时间，秒级
        > s-maxage：同max-age，适用于共享缓存（CND缓存）等
        > no-cache：不使用本地缓存，使用协商缓存
        > no-store：禁用缓存
        > public：其他用户也可使用缓存，适用于公共缓存
        > private：指定用户使用缓存，适用于公共缓存
  + 协商缓存
    + HTTP 1.0：Last-Modified，If-Modified-Since
        > 秒级判断，一秒内修改多次的时候，无法准确标注文件，精确度较低
        > 对于某些定期生成的文件，内容如果没有变化，则无法使用缓存
        > 服务器时间不精确或者与代理服务器时间不一致
    + HTTP 1.1：ETag，If-None-Match，优先级高
        > 根据哈希值判断，精确度高，消耗服务器资源也多

+ HTTP 状态码
  + 1XX：信息状态码
    + 100：接收成功
  + 2XX：成功状态码
    + 200：正常响应，跨域预检请求
    + 204：服务器没有资源返回
    + 206：客户端进行的是范围请求，COntent-Range
  + 3XX：重定向
    + 301：永久重定向
    + 302：临时重定向
    + 304：服务端直接返回缓存数据
  + 4XX：客户端错误
    + 400：请求报文语法错误
    + 401：需要经过HTTP认证
    + 403：没有权限访问
    + 404：请求的路径不存在
  + 5XX：服务端错误
    + 500：服务器执行请求错误
    + 502：服务器代理错误
    + 503：服务器处于超负载或停机维护

+ HTTP 请求的方式
  + GET
    + 参数拼接在URL中，参数大小有限制，浏览器会保留记录，不安全
    + 请求会被浏览器主动缓存
    + 只支持URL编码，参数只接受ASCII字符
    + 请求的幂等性
    + 只发送一个数据包
  + POST
    + 参数放在 request body 中，请求参数大小无限制，相对安全
    + 浏览器返回时会再次触发请求
    + 支持多种编码方式，参数类型无限制
    + 会发送两个数据包：首先发送header，服务器响应100，继续发送body（火狐浏览器一次性发送）

##### 6、服务器将响应报文通过TCP连接发送回浏览器，浏览器接收HTTP响应

##### 7、浏览器根据返回的资源类型决定如何处理（假设资源为HTML文档）

##### 8、解析HTML文档，构建DOM树，下载资源，构造CSSSOM树，执行js脚本

+ 渲染流程
  + 解析HTML文件生成DOM Tree
  + 解析CSS文件生成CSSOM Tree，此时会阻塞渲染，只有CSSOM构建完成才会进入下个阶段
  + DOM Tree 和 CSSOM Tree结合生成 Render Tree
  + 绘制页面

+ 回流和重绘
  + 回流：元素的规模尺寸，布局，隐藏那个改变而需要重新构建
  + 重绘：元素的外观，风格等不影响布局的样式改变
  + 回流一定触发重绘，重绘不一定触发回流
  + 触发回流的操作：
    > 添加或删除DOM元素
    > 元素尺寸改变 - 宽高，内外边距，边框大小
    > 内容变化：在输入框输入文字
    > 浏览器窗口尺寸变化 - resize
    > 获取，计算offsetHeight 和 offsetWidth属性
    > 设置 style 属性的值
    > window.getComputedStyle() 等
  + 相关优化
    > 使用 transform 代替 top 等进行位置操作
    > 使用 visibility 代替 display：none
    > Css选择器避免嵌套过多的层级
    > 对于要操作的DOM节点，可以先脱离文档流，操作完成后替换目标节点
    > 操作动画时使用 requestAnimationFrame
    > 将频繁回流或者重绘的节点设置为图层，图层能够避免该节点的渲染行为影响别的节点

+ 渲染问题
  + 白屏：JS的加载阻塞CSS加载或者CSS放到页面底部
  + FOUC：在CSS加载之前加载了HTML，展示出无样式内容

+ 渲染优化
  + HTML
    + 启用gzip压缩
    + CND加速
    + 资源服务器
    + 使用缓存
    + 合并js，css文件，减少请求数量
    + 优化页面的加载顺序：css在顶部加载，js在底部加载
    + 雪碧图
  + CSS：选择器从右往左查找
    + 减少使用行内样式
    + 避免过多的选择器层级
    + 避免使用通配符
  + Javascript
    + 减少行内js脚本代码
    + 优化js脚本的引入顺序
    + 使用defer属性，使脚本在文档完全呈现以后在执行
    + 使用async属性，使脚本不必等待其他脚本的执行，也不会阻塞文档的展现

##### 9、浏览器将最终的页面呈现给用户
