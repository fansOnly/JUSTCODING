#### 主要技术栈

- **Javascript 基础** - h5 + css3 + jquery
- **Javascript 进阶** - canvas + animation + echarts
- **Vue 全家桶** - vue + vuex + vue-router + element / vant
- **小程序** - uni-app
- **打包工具** -vue-cli / webpack / vite
- **包管理器** - node / yarn / pnpm
- **版本管理** - git / svn

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

##### 1、HTML 基础

- DOM 操作
  - 离线操作
  - Fragment
- 重绘和回流 ⭐️⭐️
  - 重绘：元素外观改变触发的浏览器行为
    ```js
      1、重绘并不一定导致重排
      2、重绘场景：color / background / border-style / border-radius / box-shadow / ...
    ```
  - 重排：重新生成布局，重新排列元素
    ```js
      1、重排一定导致重绘
      2、重排场景：页面初始渲染 / 添加、删除元素 / 改变元素的位置 / 改变元素尺寸 / 改变元素内容 / 改变字体大小 / 改变窗口尺寸 / 添加伪类 / 设置 style / 获取某些属性、调用某些计算方法
    ```
  - 优化
    ```js
      1、离线操作 DOM
      2、通过 className 改变样式
      3、脱离文档流
      4、读取缓存值
      5、GPU 加速：使用 transform / opacity / filter 等属性
    ```
- 事件模型
  ```js
    1. 捕获阶段：事件从 window 开始向下触发，直至到达目标元素
    2. 目标阶段：事件达到目标元素
    3. 冒泡阶段：事件从目标元素开始向上冒泡，直至达到 window
  ```
- 事件冒泡
- CSS 会不会阻塞渲染？为什么
  ```js
    1、CSS 的下载和解析不会阻塞 DOM 解析，但会阻塞 DOM 渲染
    2、渲染树是由 DOM Tree 和 CSSOM Tree 一起合成的
  ```
- JS 会不会阻塞渲染？为什么
  ```js
    1、JS 的下载和解析会阻塞 GUI 渲染进程，即阻塞 DOM 和 CSS 解析和渲染
    2、GUI 渲染进程是解析一部分就渲染一部分，不会等待全部解析完成再渲染
  ```
- 异步加载 JS 的方式？- defer/async
  ```js
    1. defer：同步下载，等待文档解析完成才执行，在 DOMContentLoaded 之前
    2. async：同步下载，下载完立即执行，顺序不固定
  ```
- event.target vs event.currentTarget
  ```js
    1. event.target：事件触发的元素
    2. event.currentTarget：事件绑定的元素
  ```

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

##### 2、CSS 基础

- HTML 加载样式的几种方式
  ```js
    1. 外部样式文件链接 <link src="" />
    2. 导入外部样式 @import "";
    3. 内联样式 <style></style>
    4. 行内样式 style=""
  ```
- CSS 选择器
  ```js
    // 优先级依次递增
    1. 元素选择器（p），伪元素（::after）
    2. 类选择器（.box），属性选择器（[type="input"]），伪类（:hover）
    3. ID 选择器（#box）
    4. 通配符选择符（*），关系选择符（+, >, ~, " "(后代选择器), ||），否定伪类（:not()）对优先级没有影响
  ```
- FOUC
  ```js
    无样式内容闪烁（Flash of UnStyled Content），在 IE 下通过 @import 引入 CSS 文件引起的。
  ```
- 边距折叠
- BFC ⭐️⭐️

  ```js
    1. 根元素 <html>
    2. 浮动元素 float 不为 none
    3. 绝对定位元素 position 不为 relative
    4. 行内块元素 display: inline-block
    5. 表格相关 display: table / table-cell / ...
    6. overflow 不为 visible
    7. 弹性元素 display: flex / inline-flex
    8. 网格元素 display: grid / inline-grid

    // BFC 为什么能清除浮动？
    BFC 元素之间都是相互独立的，内部浮动不会影响到外界其他元素
  ```

- 盒子模型
  ```js
    1. IE 怪异盒子模型：content + padding + border
    2. 标准盒子模型：content
  ```
- Flex 布局 ⭐️⭐️
  - flex 属性
    ```js
      1. display: flex / inline-flex
      2. flex-direction: row / row-reverse / column / column-reverse
      3. flex-wrap: nowrap / wrap / wrap-reverse
      4. align-items: flex-start / center / flex-end / stretch
      5. justify-content: flex-start / center / space-between / space-around / flex-end
    ```
  - flex: auto / 0 / 1
    ```js
      1. flex-grow：放大规则，容器分配剩余空间的相对比例
      2. flex-shrink：缩小规则，
      3. flex-basic：主轴方向的初始大小
    ```
- CSS 优化、提高性能的方法
  ```js
    1. 多个 css 合并，尽量减少 HTTP 请求
    2. 将 css 文件放在页面最上面
    3. 移除空的 css 规则
    4. 避免使用 CSS 表达式
    5. 选择器优化嵌套，尽量避免层级过深
    6. 充分利用 css 继承属性，减少代码量
    7. 抽象提取公共样式，减少代码量
    8. 属性值为 0 时，不加单位
    9. 属性值为小于 1 的小数时，省略小数点前面的 0
    10. css 雪碧图
  ```
- 面试题：谈谈响应式布局 ⭐️⭐️
  ```js
    1. 媒体查询：
    2. 百分比：
    3. rem：相对根元素
    4. em：相对父元素
    5. vw/vh：视口单位
    6.rpx：微信小程序
  ```
- 面试题：CSS 实现三角形
  ```js
    .triangle-bottom {
      width: 0;
      height: 0;
      border-style: solid;
      border-width: 10px;
      border-color: #f00 transparent transparent;
    }
  ```
- 面试题：CSS 实现扇形
  ```js
    .triangle-bottom {
      width: 0;
      height: 0;
      border-style: solid;
      border-width: 10px;
      border-color: #f00 transparent transparent;
      border-radius: 10px;
    }
  ```
- 面试题：实现不定宽高元素水平垂直居中 ⭐️
  ```js
    // 1. flex 布局 - 不定宽高
    .center {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    // 2. 定位 - 不定宽高
    .center {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      /* margin: -50% -50% 0 0; */
    }
    // 3. 固定元素
    .center {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      margin: auto;
    }
  ```
- 面试题：品字布局/圣杯布局/双飞翼布局
- 面试题：display: none / visibility: hidden / opacity: 0 的区别

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

##### 3、JS 基础

- 数据类型
  > 1. 基本类型：Undefined, Null, Boolean, String, Number, Symbol, BigInt
  > 2. 引用类型：Object
- 包装对象

  > 指的是与数值、字符串、布尔值分别相对应的 Number、String、Boolean 三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。

  > 为什么一个字符串可以有 length 属性？

- 闭包 ⭐️⭐️
  - 什么是闭包：当一个函数内部可以访问外部函数的作用域时，产生了闭包
  - 内存泄漏
- es5 继承相关 ⭐️⭐️⭐️
  > 1、原型链继承
  > 2、构造函数继承
  > 3、组合继承
  > 4、原型式继承
  > 5、寄生式继承
  > 6、寄生组合继承
- 作用域 & this

  - 作用域分类

    > 1、全局作用域
    > 2、函数作用域
    > 3、块级作用域

  - 执行上下文

    > 创建过程：
    > 1、创建变量对象
    > 2、生成作用域连
    > 3、确定 this 指向

    > 执行过程：
    > 1、变量赋值
    > 2、函数引用
    > 3、执行其他代码

  - this 继承

- 原型链
  - 关系图
    ![Alt text](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/%E5%8E%9F%E5%9E%8B%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg)
  - 如何创建一个没有 prototype(原型) 的对象
- 变量提升
  > 1、函数提升优先，函数体会跟随函数声明一起提升
  > 2、函数同名变量提升会被忽略
- bind vs call vs apply

  - [代码实现](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/call-apply-bind.js)

- 事件循环：EventLoop ⭐️⭐️⭐️

  ![Alt text](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/EventLoop.PNG)

- requestAnimationFrame ⭐️⭐️

  > 1、CPU 节能：页面未激活时，屏幕刷新任务也停止了
  > 2、函数节流：保证在每个刷新周期内（16.7ms for 60Hz）只执行一次
  > 3、[demo 示例](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/requestAnimationFrame.html)

- 正则相关 ⭐️⭐️⭐️

- 面试题：手写 es5 继承(5 种) ⭐️⭐️⭐️

  - [代码实现](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/%E7%BB%A7%E6%89%BF.md)

- 面试题：首先 new / instanceOf / create ⭐️⭐️

  - [代码实现](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/new-create-instanceof.js)

- 面试题：数据类型判断 typeof vs instanceOf vs 内部属性\[[Class]]:['Object xxx']

- 面试题：描述 Javascript 中相等和全等的区别

  ![Alt text](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/==%20&%20===.png)

- 面试题：实现 a == 1 && a == 2 ⭐️⭐️

  - [代码实现](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/a%20==%201%20&%20a%20==%202.js)

- 面试题：实现一个 event 类(发布订阅模式/观察者模式) ⭐️⭐️⭐️

  - [代码实现](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/event-bus.js)

- 面试题：实现一个金钱格式化函数 1000000 => 1,000,000

  ```js
  const formatNumber = (val) => {
    return val.replace(/(?!^)(?=(\d{3})+(?!\d))/g, ',')
  }
  ```

- 面试题：实现一个并发请求控制函数 asyncPool
  - [代码实现](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/async-load-image.js)

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

##### 4、ES6+

- 新特性介绍
  - 箭头函数
    > 1、没有 this，arguments，不能用做构造函数
    > 2、定义时确定 this 指向，继承外层第一个普通函数的 this
    > 3、通过 call，apply，bind 调用时，第一个参数（绑定的 this）会被忽略
  - 解构赋值
  - 扩展运算符：展开式运算符和剩余运算符
  - 模版字符串
  - 对象字面量
  - 函数默认参数
  - Promise
  - Map / Set
  - Proxy
  - ...
- 数组方法
  - 改变原数组的方法
    > unshift / shift / push / pop / sort / splice / reverse
  - 迭代方法
    > forEach / map / filter / every / some / keys / values / entries
  - 查找方法
    > includes / find / findIndex / indexOf / lastIndexOf
  - 归并方法
    > reduce / reduceRight
  - ...
- Promise vs async / await vs callback
  ```js
    1. async 函数在抛出返回值时，会根据返回值类型开启不同数目的微任务
       return 结果值：非 thenable、非 promise（不等待）
       return 结果值：thenable（等待 1个 then 的时间）
       return 结果值：promise（等待 2个 then 的时间）
  ```
- let vs const
- 箭头函数 vs 普通函数
- 迭代器 vs 生成器 ⭐️⭐️⭐️

  ```js
    1、迭代器和生成器内部都实现了 next() 方法
    2、调用后返回类似的数据结构 { value: [any], done: [Boolean] }
  ```

- 面试题：手写数组方法

  - [map](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/Array/array-map.js)
  - [find](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/Array/array-find.js)
  - [filter](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/Array/array-filter.js)
  - [reduce](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/Array/array-reduce.js)

- 面试题：手写 Promise ⭐️⭐️⭐️⭐️⭐️

  - [代码实现](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/Promise/index.js)

- 面试题：数组去重

  - [代码实现](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/Array/array-de-duplication.js)

- 面试题：数组扁平化

  - [代码实现](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/Array/array-flat.js)

- 面试题：实现管道函数 compose / pipe ⭐️⭐️

  - [代码实现](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/Array/compose-pipe.js)

- 面试题：for / for...of / map / forEach 性能、区别、场景

  > 1、for 循环是底层实现，可以通过 continue、break 控制
  > 2、for...of 是迭代行为，需要内部实现 [@@iterator]，可迭代字符串、数组、Map、Set、生成器对象
  > 3、map 适用于数组的遍历，不可控制，跳过 undefined 值，返回一个新数组
  > 4、forEach 适用于数组、Map、Set 的遍历，不可控制，没有返回值

- 面试题：for...in vs for...of

  > 1、for...in 遍历对象自身属性，拿到的是 key 值
  > 2、for...of 遍历数组，拿到的是 value 值

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

##### 5、浏览器

- 跨域: 协议、域名、端口
  - jsonP
  - CORS
  - Nginx
  - webpack
- 浏览器存储
  - cookie
    > 本地存储，单个 cookie 一般 4k 左右，一个域名一般限制 50 个 cookie
  - session
    > 服务端存储，一般用作会话状态验证
  - localStorage
    > 客户端存储，大小 5M 左右
  - sessionStorage
    > 客户端存储，仅在当前网页会话下有效，大小 5M 左右
- HTTP 状态码
  - 2xx
  - 3xx
  - 4xx
  - 5xx
- HTTP 缓存 ⭐️⭐️
  - 强缓存
    > 1、Expires：设置资源到期时间
    > 2、Cache-Control：设置资源有效时长
    > 3、Cache-Control 的值
    >
    > > 3.1 no-cache：不使用强缓存，使用协商缓存
        3.2 no-store： 不使用缓存
        3.3 public：共享缓存，可以被任何对象如代理服务器缓存
        3.4 private：私有缓存，只能被客户端缓存
        3.5 max-age：\<seconds> 存储的最大周期
        3.6 s-maxage：\<seconds>，覆盖 max-age，适用于共享缓存
  - 弱缓存
    > 1、Last-Modified：对比文件修改时间
    > 2、ETag：对比文件哈希值（强/弱哈希）
- HTTP 1.0 vs HTTP 1.1 vs HTTP 2.0 vs HTTP 3.0
- TCP vs UDP ⭐️⭐️⭐️
  ||TCP|UDP|
  |-|-|-|
  |是否连接|面向连接|无连接|
  |是否可靠|可靠传输，流量控制和拥塞控制|不可靠传输|
  |连接对象个数|一对一|一对一、一对多、多对一、多对多|
  |传输方式|面向字节流|面向报文|
  |首部开销|最小 20 字节，最大 60 字节|8 字节|
  |使用场景|稳定场景：文件传输、网页请求等|实时传输场景：视频、直播等|
- HTTPS ⭐️⭐️⭐️⭐️

- 三次握手 & 四次挥手 ⭐️⭐️⭐️⭐️
  ![Alt text](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/images/http-connect.jpg)

- DNS 相关 ⭐️⭐️⭐️
  - 递归查询
  - 迭代查询
  - [文档](%E9%9D%A2%E8%AF%95%E8%BE%85%E5%8A%A9%E5%8C%85/HTTP/DNS-%E8%A7%A3%E6%9E%90.md)
- GET vs POST
  ||POST|GET|
  |-|-|-|
  |安全性|通过 body 发送数据|参数暴露在 URL 中|
  |参数长度|一般没有限制|受限于浏览器对 URL 长度的限制，一般 2K 左右|
  |参数类型|没有限制|ASCII 字符|
  |参数编码|application/x-www-form-urlencoded、multipart/form-data| application/x-www-form-urlencoded |
  |缓存|默认没有缓存|默认缓存|
  |幂等性|无|幂等|
- 垃圾回收机制 ⭐️⭐️⭐️⭐️⭐️
  ```js
    1、新生代，空间小，8M 左右，From & To，清理未使用对象，20%边界，2次晋升
    2、老生代，空间大，标记清除，标记整理
    3、优化，增量标记，三色标记
  ```
- 网络安全 ⭐️⭐️
  - XSS：跨站脚本攻击
    > 存储型、反射型、DOM 型
    > 1、输入转义、过滤
    > 2、HTTPonly
    > 3、CSP
  - CSRF：跨站请求伪造
    > 1、CSRF Token
    > 2、Referer 验证
    > 3、SameSite = strict / lax
- 面试题：浏览器渲染的过程 ⭐️⭐️⭐️
  > 1、解析 DOM，生成 DOM Tree
  > 2、解析 CSSSOM，生成 CSSOM Tree
  > 3、合成 Render Tree
  > 4、GPU 图层合成，展示页面
- 面试题：从输入 URL 到页面呈现发生了什么 ⭐️⭐️⭐️⭐️⭐️
  > 1、组装 url 地址，发起请求
  > 2、DNS 解析
  > 3、HTTP 连接
  > 4、返回响应 - html
  > 5、渲染页面
  > 6、关闭连接

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

##### 6、Vue 全家桶

- Vue2
  - 响应式原理：发布订阅模式 & 数据劫持(Object.defineProperty) ⭐️⭐️⭐️⭐️⭐️
  - 生命周期
  - 组件通信
  - data 为什么是函数
  - computed vs watch
  - 父子组件生命周期执行顺序
  - Vue 中对于数组的特殊处理 ⭐️⭐️
  - Vue 中的事件修饰符
  - v-if & v-for
  - 什么是函数式组件
  - Vue 解析 DOM 的过程：template -> compiler -> AST -> render -> vNode -> parse -> DOM
  - 插槽相关：默认插槽 vs 命名插槽 vs 作用域插槽 ⭐️⭐️⭐️
  - 虚拟 DOM vs 真实 DOM
  - Vue 中 key 的作用
  - Vue Diff 算法 ⭐️⭐️⭐️⭐️⭐️
  - Vue 初始化的顺序
  - Vue SSR ⭐️⭐️⭐️⭐️
  - Vue 和 React 的区别
  - Vue3 ⭐️⭐️⭐️⭐️⭐️
  - 面试题：实现一个滚动虚拟列表 ⭐️⭐️⭐️⭐️⭐️
  - 如何设计一个组件：按钮 ⭐️⭐️⭐️⭐️
- Vue-Router
  - 路由模式
  - hash vs history(404)
  - 路由懒加载
  - 路由分块打包
  - 7 个路由守卫 ⭐️⭐️⭐️⭐️
  - 面试题：路由权限控制 ⭐️⭐️⭐️⭐️⭐️
- Vuex
  - 五要素
  - 同步修改和异步修改
  - 模块化
  - 如何解决页面刷新时 Vuex 数据丢失 ⭐️⭐️⭐️
- Vue-cli ⭐️⭐️⭐️⭐️
  - 配置相关
  - assets vs static 的区别
- Axios ⭐️⭐️⭐️⭐️
  - 如何封装请求
  - 拦截器
  - 取消请求

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

##### 7、Webpack / Vue-cli ⭐️⭐️⭐️⭐️⭐️

- 基础配置：入口/出口等
- loader
  - 实现原理 - 转换文件
  - 常见的 loader
  - 编写 loader
- plugins
  - 实现原理 - 事件流机制
  - 常见的插件
  - 编写 plugin
    - apply
- Webpack 是如何打包的
  1. 搭建架构，读取配置参数
  2. 根据配置参数初始化 Compiler 对象
  3. 挂载配置文件中的插件
  4. 执行 Compiler 对象的 run 方法开始编译
  5. 根据配置文件的 entry 找到所有的入口
  6. 根据入口文件，调用 loader 对模块进行编译
  7. 递归编译所有模块的依赖模块
  8. 编译完所有模块后，根据依赖关系，生成代码 chunk
  9. 将所有的 chunk 转换成输出文件
  10. 根据配置的出口和文件名，讲文件输出到文件系统
- 打包优化
  - 图片压缩
  -
- tree-shaking
  - 依赖 esModule
  - sideEffect

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

##### 8、前端理论知识 ⭐️⭐️⭐️⭐️⭐️

- 前端优化：工程层面 / 代码层面 / 网络层面
- 前端工程化介绍：CommonJS vs AMD vs CMD vs UMD vs esModule
- 视图模型：MVC / MVVM
- export & import 相关
  - 默认导出
  - 多个导出
  - 导出值/引用
- Babel vs polyfill

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

##### 9、面试题

- this 指向问题 ⭐️⭐️⭐️
- 微任务 & 宏任务执行顺序题目
- 手写深克隆
- 防抖函数 & 节流函数
- 函数柯里化/反柯里化
- 0.1 + 0.2 == 0.3
- 如何捕获程序运行过程中的错误
  - try...catch
  - window.onerror = () => {}
  - Vue.config.errorHandler = () => {}
  - window.addEventListener('unhandledrejection', () => {})
- 斐波那契：2 种实现方式 ⭐️⭐️
- 实现一个任务队列 Job Queue ⭐️⭐️⭐️⭐️
- 打印九九乘法表 ⭐️⭐️⭐️
- 算法相关之数组排序 ⭐️⭐️⭐️⭐️⭐️
  - 快速排序
  - 冒泡排序
  - 选择排序
  - 插入排序
  - 堆排序
  - 归并排序
  - 桶排序
- 其他算法题 ⭐️⭐️⭐️⭐️⭐️

##### 10、包管理 ⭐️⭐️⭐️⭐️⭐️

- npm
- yarn
- pnpm

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

##### 11、版本管理 ⭐️⭐️⭐️

- git
- svn

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

##### 12、个人总结 ⭐️⭐️⭐️⭐️⭐️

- 项目总结
- 职业规划

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

##### 13、面试结束应该向公司了解什么

- 确认公司岗位的真实性及工作内容：技术架构、团队规模、项目概况等
- 询问公司岗位的发展空间（晋升空间、培训机会等）
- 询问公司福利相关，需要了解到大致的数字

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

##### 14、部分题目

```js
console.log([] == ![])

console.log({} == !{})
```

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

```js
function Ofo() {}

function Bike() {
  this.name = 'mybike'
}

var myBike = new Ofo()

Ofo.prototype = new Bike()

console.log(Ofo)
console.log(myBike)

console.log(myBike.name)

var yourBike = new Bike()

console.log(yourBike.name)
```

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

```js
function test(a, b) {
  console.log(b)
  return {
    test: function (c) {
      return test(c, a)
    },
  }
}

var retA = test(0)
retA.test(2)
retA.test(4)
retA.test(8)

var retB = test(0).test(2).test(4).test(8)

var retC = test('good').test('bad')
retC.test('good')
retC.test('bad')
```

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

```js
var v = new Promise((resolve) => {
  console.log('begin')
  resolve('then')
})

new Promise((resolve) => {
  resolve(v)
}).then((v) => {
  console.log(v)
})

new Promise((resolve) => {
  console.log(1)
  resolve()
})
  .then(() => {
    console.log(2)
  })
  .then(() => {
    console.log(3)
  })
  .then(() => {
    console.log(4)
  })
```

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

```js
var v = new Promise((resolve) => {
  console.log('begin')
  resolve('then')
})

Promise.resolve(v).then((res) => {
  console.log(res)
})

new Promise((resolve) => {
  console.log(1)
  resolve()
})
  .then(() => {
    console.log(2)
  })
  .then(() => {
    console.log(3)
  })
  .then(() => {
    console.log(4)
  })
```

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

```js
function Foo() {
  getName = function () {
    return 1
  }
  return this
}
Foo.getName = function () {
  return 2
}
Foo.prototype.getName = function () {
  return 3
}
var getName = function () {
  return 4
}
function getName() {
  return 5
}

console.log(Foo.getName())

console.log(getName())

console.log(Foo().getName())

console.log(getName())

console.log(new Foo.getName())

console.log(new Foo().getName())

console.log(new new Foo().getName())
```

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

```js
var x = 2
var y = {
  x: 3,
  z: (function (x) {
    this.x *= x
    x += 2
    return function (n) {
      this.x *= n
      x += 3
      console.log(x)
    }
  })(x),
}

var m = y.z
m(4)

y.z(5)

console.log(x, y.x, y.z)
```

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

```js
var x = 0,
  y = 1

function fn() {
  x += 2
  fn = function (y) {
    console.log(y + --x)
  }
  console.log(x, y)
}

fn(3)
fn(4)

console.log(x, y)
```

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

```js
{
  a = 1
  function a() {}
  a = 2
  console.log(a)
}
console.log(a)
```

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

```js
var n = 2
var obj = {
  n: 3,
  fn: (function (n) {
    n *= 2
    this.n += 2
    var n = 5
    console.log('window.n', window.n)
    return function (m) {
      console.log('n:', n, 'm', m)
      this.n *= 2
      console.log(m + ++n)
    }
  })(n),
}

var fn = obj.fn
fn(3)
obj.fn(3)
console.log(n, obj.n)
```

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

```js
function foo(a, b = 1, c) {
  console.log(foo.length)
  console.log(arguments.length)
}

foo(1, 2, 3)
```

<hr style="height:0px;border:none;border-top:2px solid #d8d8d8;" />

```js
var a = { n: 1 }
var b = a
a.x = a = { n: 2 }

console.log(a.x)
console.log(b.x)
```
