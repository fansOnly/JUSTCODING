// TCP 连接
// 1 SYN 报文用来同步
// 2 ACk 报文用来应答
// 3 FIN 报文



// 三次握手
// 1、客户端 请求 服务端
// 2、服务端 响应 客户端
// 3、客户端 发送数据

// 第一次挥手 - 客户端发送syn(同步序列号)包SYN=1到服务器, seq=x 表示数据起始位置为x, 并进入SYN_SENT状态, 等待服务器回应
// 第二次握手 - 服务端向客户端返回ACK=1 表示确认收到, seq=y 表示数据起始位置为y, SYN=1 表示建立连接, ack=x+1 表示希望客户端下次发送数据从x+1开始, 进入SYN_RECV状态
// 第三次握手 - 客户端ACK=1 表示确认收到, seq=x+1 表示按照服务端要求位置发送数据, ack=y+1 表示希望服务端下次发送数据从y+1开始, 客户端进入ESTABLISHED状态
// 服务端接收后进入ESTABLISHED状态




// 四次挥手  主动方 被动方
// 1、主动方 通知 被动方
// 2、服务器 请求 客户端, 并进入准备状态
// 3、服务器 请求 客户端
// 4、客户端 响应 服务器

// 第一次挥手 - 主动方向被动方发送FIN=1 表示断开连接, seq=x 表示数据起始位置为x, 主动方进入FIN_WAIT_1状态
// 第二次挥手 - 服务端向客户端发送ACK=1表示收到, 发送ack=x+1 表示希望客户端下次发送数据从x+1开始, 服务端进入FIN_WAIT_2状态
// 第三次挥手 - 服务端准备完成后向客户端发送FIN=1表示同意断开连接, 发送seq=y表示数据位置从y开始, 进入LAST_ACK状态
// 第四次挥手 - 客户端向服务端发送ACK=1表示确认收到, 发送ack=y+1 表示希望服务端下次发送数据从y+1开始, 进入TIME_WAIT状态
// 客户端等待2MSL(2个最长报文段寿命), 如果服务端没有重传数据包, 表示已收到消息, 服务端最终进入CLOSE状态, 客户端也进入CLOSE状态, TCP断开连接




// 服务器建立连接后, 客户端发生故障
// TCP设有一个保活计时器, 服务端没收到一次客户端的请求就会重置这个计时器, 时间一般为2小时, 如果2个小时内服务端没有收到客户端的请求, 会尝试发送一个探测报文, 以后每75s发送一次, 若连续发送10次仍然没有收到客户端的响应, 则会主动断开TCP连接
