// ================================================================================================================
// ================================================ 一面 ===========================================================
// ================================================================================================================

// *********************************************************************************************************
// webpack 原理

// 1 初始化参数: 从配置文件和 Shell 语句中读取与合并参数, 得出最终参数配置
// 2 开始编译: 用上一步得到的参数初始化 Compiler 对象, 加载所有配置的插件,  执行对象的 run 方法开始执行编译
// 3 确定入口: 根据配置中的 entry 找出所有的入口文件
// 4 编译模块: 从入口文件出发, 调用所有配置的 loader 对模块进行翻译, 再找出该模块所依赖的模块, 不停递归直至所有入口文件依赖的模块均被处理完成
// 5 模块编译完成: 所有模块被翻译完成后, 得到每个模块被翻译后的内容及其依赖关系
// 6 输出资源: 根据入口和模块的依赖关系, 组装成一个个包含多个模块的 Chunk, 再将 Chunk 转换成单独的文件加入到输出列表, 这是修改输出内容的最后机会
// 7 输出完成: 确定输出内容后, 根据配置确定输出的路径和文件名, 把内容写入到文件系统





// *********************************************************************************************************
// babel 原理
// parsing transforming generatng

// 1 ES6 代码输入
// 2 通过 babelon 解析得到 AST
// 3 plugin 通过 babel-travers 对 AST 进行遍历得到新的 AST
// 4 babel-generator 通过 ATS 生成 ES5 代码



// *********************************************************************************************************
// 虚拟 DOM

// 1 维护一个 JS 对象形式的 Virtual DOM, 与真实 DOM 一一对应
// 2 对连个 DOM 做 diff, 生成变更 Mutation
// 3 把变更应用于真实 DOM, 生成最新的真实 DOM

// 1 虚拟 DOM 并不一定比直接更新 DOM 快
// 2 初次渲染时, 虚拟 DOM 会比操作 innerHTML 慢
// 3 虚拟 DOM 需要在内存中保留一份 DOM 的备份
// 4 虚拟 DOM 抽象了渲染过程, 实现了跨平台渲染的能力